//
//  HHMachExceptionHandler.m
//  VisionIOS
//
//  Created by shen on 2019/2/14.
//  Copyright © 2019 华生侯. All rights reserved.
//

#import "HHMachExceptionHandler.h"
#import "HHLogger.h"
#import "mach/mach.h"
#import "mach/message.h"

typedef struct {
    
    mach_msg_header_t Head;
    mach_msg_body_t Body;
} MachMessage;

@implementation HHMachExceptionHandler

// Handle EXCEPTION_DEFAULT behavior
kern_return_t catch_mach_exception_raise (mach_port_t exception_port,
                                          mach_port_t thread,
                                          mach_port_t task,
                                          exception_type_t exception,
                                          mach_exception_data_t code,
                                          mach_msg_type_number_t codeCnt)
{
    // Do smart stuff here.
    fprintf(stderr, "My exception handler was called by exception_raise()\n");
    [HHLogger saveToFile:@"fucked!"];

    // Inform the kernel that we haven't handled the exception, and the
    // next handler should be called.
    return KERN_FAILURE;
}

+ (void)createAndSetExceptionPort {
    
    mach_port_t server_port;
    kern_return_t kern = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &server_port);
    assert(kern == KERN_SUCCESS);
    printf("get port:%d\n", server_port);
    
    kern = mach_port_insert_right(mach_task_self(), server_port, server_port, MACH_MSG_TYPE_MAKE_SEND);
    assert(kern == KERN_SUCCESS);
    
    kern = task_set_exception_ports(mach_task_self(),
                                    EXC_MASK_BAD_ACCESS,
                                    server_port, EXCEPTION_DEFAULT|MACH_EXCEPTION_CODES, THREAD_STATE_NONE);
    assert(kern == KERN_SUCCESS);
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{
        
        exception_server(server_port);
    });
}

static void exception_server (mach_port_t exceptionPort) {
    mach_msg_return_t rt;
    mach_msg_header_t *msg;
    mach_msg_header_t *reply;
    MachMessage *message;
    
    msg = malloc(sizeof(mach_msg_header_t) + 1024);
    reply = malloc(sizeof(mach_msg_header_t) + 1024);
    
//    mach_message message;
    
    while (1) {
        rt = mach_msg(msg, MACH_RCV_MSG, 0, sizeof(mach_msg_header_t) + 1024, exceptionPort, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
        assert(rt == MACH_MSG_SUCCESS);
        
        message = msg;
        // Call out to the mach_exc_server generated by mig and mach_exc.defs.
        // This will in turn invoke one of:
        // mach_catch_exception_raise()
        // mach_catch_exception_raise_state()
        // mach_catch_exception_raise_state_identity()
        // .. depending on the behavior specified when registering the Mach exception port.
//        mach_exc_server(msg, reply);
        printf("msg received!\n");
//        abort();
        // Send the now-initialized reply
        rt = mach_msg(reply, MACH_SEND_MSG, sizeof(mach_msg_header_t) + 1024, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
        assert(rt == MACH_MSG_SUCCESS);
    }
}

@end
